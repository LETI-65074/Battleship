<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/App.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/App.java" />
              <option name="originalContent" value="package iscteiul.ista;&#10;&#10;import iscteiul.ista.battleship.*;&#10;&#10;/**&#10; * @author britoeabreu&#10; * @author adrianolopes&#10; * @author miguelgoulao&#10; */&#10;public class App&#10;{&#10;    public static void main( String[] args )&#10;    {&#10;&#10;        System.out.printf(&quot;\n***  Battleship Game ***\n&quot;);&#10;&#10;    //Game game = new Game(new Fleet());&#10;&#10;&#10;        // Tasks.taskA();&#10;       // Tasks.taskB(new Game(new Fleet()));&#10;&#10;        Game game = new Game(new Fleet()); // usa a tua implementação concreta&#10;        try (java.util.Scanner sc = new java.util.Scanner(System.in)) {&#10;            IShip sunk;&#10;            while (true) {&#10;                System.out.print(&quot;Tiro (linha,coluna) ou q: &quot;);&#10;                String s = sc.nextLine().trim();&#10;                if (s.equalsIgnoreCase(&quot;q&quot;)) break;&#10;                String[] p = s.split(&quot;,&quot;);&#10;                IPosition pos = new Position(Integer.parseInt(p[0]), Integer.parseInt(p[1]));&#10;                 sunk = game.fire(pos);&#10;                System.out.println(sunk != null ? &quot;Afundou!&quot; : &quot;—&quot;);&#10;            }&#10;        }&#10;        //&#9;Tasks.taskC();&#10;        //&#9;Tasks.taskD();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package iscteiul.ista;&#10;&#10;import iscteiul.ista.battleship.*;&#10;&#10;/**&#10; * Minimal entry point to run the Battleship interactive console.&#10; * Demonstrates creating a game and reading shot coordinates from stdin.&#10; */&#10;public class App&#10;{&#10;    /**&#10;     * Application entrypoint. Reads user input lines with &quot;row,column&quot; pairs&#10;     * and fires at the created Game. Enter 'q' to quit.&#10;     *&#10;     * @param args command line arguments (ignored)&#10;     */&#10;    public static void main( String[] args )&#10;    {&#10;&#10;        System.out.printf(&quot;\n***  Battleship Game ***\n&quot;);&#10;&#10;    //Game game = new Game(new Fleet());&#10;&#10;&#10;        // Tasks.taskA();&#10;       // Tasks.taskB(new Game(new Fleet()));&#10;&#10;        Game game = new Game(new Fleet()); // usa a tua implementação concreta&#10;        try (java.util.Scanner sc = new java.util.Scanner(System.in)) {&#10;            IShip sunk;&#10;            while (true) {&#10;                System.out.print(&quot;Tiro (linha,coluna) ou q: &quot;);&#10;                String s = sc.nextLine().trim();&#10;                if (s.equalsIgnoreCase(&quot;q&quot;)) break;&#10;                String[] p = s.split(&quot;,&quot;);&#10;                IPosition pos = new Position(Integer.parseInt(p[0]), Integer.parseInt(p[1]));&#10;                 sunk = game.fire(pos);&#10;                System.out.println(sunk != null ? &quot;Afundou!&quot; : &quot;—&quot;);&#10;            }&#10;        }&#10;        //&#9;Tasks.taskC();&#10;        //&#9;Tasks.taskD();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Barge.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Barge.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Barge extends Ship {&#10;    private static final Integer SIZE = 1;&#10;    private static final String NAME = &quot;Barca&quot;;&#10;&#10;    /**&#10;     * @param bearing - barge bearing&#10;     * @param pos     - upper left position of the barge&#10;     */&#10;    public Barge(Compass bearing, IPosition pos) {&#10;        super(Barge.NAME, bearing, pos);&#10;        getPositions().add(new Position(pos.getRow(), pos.getColumn()));&#10;    }&#10;&#10;    @Override&#10;    public Integer getSize() {&#10;        return SIZE;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Single-cell ship (Barge).&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Barge extends Ship {&#10;    private static final Integer SIZE = 1;&#10;    private static final String NAME = &quot;Barca&quot;;&#10;&#10;    /**&#10;     * Create a single-cell Barge at the provided position.&#10;     *&#10;     * @param bearing the bearing of the barge (ignored for size 1 but kept for API consistency)&#10;     * @param pos     upper-left position of the barge (its single occupied cell)&#10;     */&#10;    public Barge(Compass bearing, IPosition pos) {&#10;        super(Barge.NAME, bearing, pos);&#10;        getPositions().add(new Position(pos.getRow(), pos.getColumn()));&#10;    }&#10;&#10;    /**&#10;     * Returns the fixed size (number of cells) of this ship type.&#10;     *&#10;     * @return ship size in grid cells&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return SIZE;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Carrack.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Carrack.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Carrack extends Ship {&#10;    private static final Integer SIZE = 3;&#10;    private static final String NAME = &quot;Nau&quot;;&#10;&#10;    /**&#10;     * @param bearing&#10;     * @param pos&#10;     */&#10;    public Carrack(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Carrack.NAME, bearing, pos);&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for the carrack&quot;);&#10;        }&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.Ship#getSize()&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Carrack.SIZE;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Carrack ship implementation (length 3).&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Carrack extends Ship {&#10;    private static final Integer SIZE = 3;&#10;    private static final String NAME = &quot;Nau&quot;;&#10;&#10;    /**&#10;     * Construct a Carrack oriented along the given bearing.&#10;     *&#10;     * @param bearing orientation for placement&#10;     * @param pos     reference starting position&#10;     * @throws IllegalArgumentException if bearing is invalid&#10;     */&#10;    public Carrack(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Carrack.NAME, bearing, pos);&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for the carrack&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns the fixed size (number of cells) of this ship type.&#10;     *&#10;     * @return ship size in grid cells&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Carrack.SIZE;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Fleet.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Fleet.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Fleet implements IFleet {&#10;    /**&#10;     * This operation prints all the given ships&#10;     *&#10;     * @param ships The list of ships&#10;     */&#10;    static void printShips(List&lt;IShip&gt; ships) {&#10;        for (IShip ship : ships)&#10;            System.out.println(ship);&#10;    }&#10;&#10;    // -----------------------------------------------------&#10;&#10;    private List&lt;IShip&gt; ships;&#10;&#10;    public Fleet() {&#10;        ships = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public List&lt;IShip&gt; getShips() {&#10;        return ships;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#addShip(battleship.IShip)&#10;     */&#10;    @Override&#10;    public boolean addShip(IShip s) {&#10;        boolean result = false;&#10;        if ((ships.size() &lt;= FLEET_SIZE) &amp;&amp; (isInsideBoard(s)) &amp;&amp; (!colisionRisk(s))) {&#10;            ships.add(s);&#10;            result = true;&#10;        }&#10;        return result;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#getShipsLike(java.lang.String)&#10;     */&#10;    @Override&#10;    public List&lt;IShip&gt; getShipsLike(String category) {&#10;        List&lt;IShip&gt; shipsLike = new ArrayList&lt;&gt;();&#10;        for (IShip s : ships)&#10;            if (s.getCategory().equals(category))&#10;                shipsLike.add(s);&#10;&#10;        return shipsLike;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#getFloatingShips()&#10;     */&#10;    @Override&#10;    public List&lt;IShip&gt; getFloatingShips() {&#10;        List&lt;IShip&gt; floatingShips = new ArrayList&lt;&gt;();&#10;        for (IShip s : ships)&#10;            if (s.stillFloating())&#10;                floatingShips.add(s);&#10;&#10;        return floatingShips;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#shipAt(battleship.IPosition)&#10;     */&#10;    @Override&#10;    public IShip shipAt(IPosition pos) {&#10;        for (int i = 0; i &lt; ships.size(); i++)&#10;            if (ships.get(i).occupies(pos))&#10;                return ships.get(i);&#10;        return null;&#10;    }&#10;&#10;    private boolean isInsideBoard(IShip s) {&#10;        return (s.getLeftMostPos() &gt;= 0 &amp;&amp; s.getRightMostPos() &lt;= BOARD_SIZE - 1 &amp;&amp; s.getTopMostPos() &gt;= 0&#10;                &amp;&amp; s.getBottomMostPos() &lt;= BOARD_SIZE - 1);&#10;    }&#10;&#10;    private boolean colisionRisk(IShip s) {&#10;        for (int i = 0; i &lt; ships.size(); i++) {&#10;            if (ships.get(i).tooCloseTo(s))&#10;                return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;&#10;    /**&#10;     * This operation shows the state of a fleet&#10;     */&#10;    public void printStatus() {&#10;        printAllShips();&#10;        printFloatingShips();&#10;        printShipsByCategory(&quot;Galeao&quot;);&#10;        printShipsByCategory(&quot;Fragata&quot;);&#10;        printShipsByCategory(&quot;Nau&quot;);&#10;        printShipsByCategory(&quot;Caravela&quot;);&#10;        printShipsByCategory(&quot;Barca&quot;);&#10;    }&#10;&#10;    /**&#10;     * This operation prints all the ships of a fleet belonging to a particular&#10;     * category&#10;     *&#10;     * @param category The category of ships of interest&#10;     */&#10;    public void printShipsByCategory(String category) {&#10;        assert category != null;&#10;&#10;        printShips(getShipsLike(category));&#10;    }&#10;&#10;    /**&#10;     * This operation prints all the ships of a fleet but not yet shot&#10;     */&#10;    public void printFloatingShips() {&#10;        printShips(getFloatingShips());&#10;    }&#10;&#10;    /**&#10;     * This operation prints all the ships of a fleet&#10;     */&#10;    void printAllShips() {&#10;        printShips(ships);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Default implementation of IFleet. Manages ship storage and placement rules.&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Fleet implements IFleet {&#10;    /**&#10;     * Print a list of ships to stdout.&#10;     *&#10;     * @param ships The list of ships&#10;     */&#10;    static void printShips(List&lt;IShip&gt; ships) {&#10;        for (IShip ship : ships)&#10;            System.out.println(ship);&#10;    }&#10;&#10;    // -----------------------------------------------------&#10;&#10;    private List&lt;IShip&gt; ships;&#10;&#10;    public Fleet() {&#10;        ships = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public List&lt;IShip&gt; getShips() {&#10;        return ships;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#addShip(battleship.IShip)&#10;     */&#10;    @Override&#10;    public boolean addShip(IShip s) {&#10;        boolean result = false;&#10;        if ((ships.size() &lt;= FLEET_SIZE) &amp;&amp; (isInsideBoard(s)) &amp;&amp; (!colisionRisk(s))) {&#10;            ships.add(s);&#10;            result = true;&#10;        }&#10;        return result;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#getShipsLike(java.lang.String)&#10;     */&#10;    @Override&#10;    public List&lt;IShip&gt; getShipsLike(String category) {&#10;        List&lt;IShip&gt; shipsLike = new ArrayList&lt;&gt;();&#10;        for (IShip s : ships)&#10;            if (s.getCategory().equals(category))&#10;                shipsLike.add(s);&#10;&#10;        return shipsLike;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#getFloatingShips()&#10;     */&#10;    @Override&#10;    public List&lt;IShip&gt; getFloatingShips() {&#10;        List&lt;IShip&gt; floatingShips = new ArrayList&lt;&gt;();&#10;        for (IShip s : ships)&#10;            if (s.stillFloating())&#10;                floatingShips.add(s);&#10;&#10;        return floatingShips;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#shipAt(battleship.IPosition)&#10;     */&#10;    @Override&#10;    public IShip shipAt(IPosition pos) {&#10;        for (int i = 0; i &lt; ships.size(); i++)&#10;            if (ships.get(i).occupies(pos))&#10;                return ships.get(i);&#10;        return null;&#10;    }&#10;&#10;    private boolean isInsideBoard(IShip s) {&#10;        return (s.getLeftMostPos() &gt;= 0 &amp;&amp; s.getRightMostPos() &lt;= BOARD_SIZE - 1 &amp;&amp; s.getTopMostPos() &gt;= 0&#10;                &amp;&amp; s.getBottomMostPos() &lt;= BOARD_SIZE - 1);&#10;    }&#10;&#10;    private boolean colisionRisk(IShip s) {&#10;        for (int i = 0; i &lt; ships.size(); i++) {&#10;            if (ships.get(i).tooCloseTo(s))&#10;                return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;&#10;    /**&#10;     * Show the fleet status summary (prints categories and floating/sunk info).&#10;     */&#10;    public void printStatus() {&#10;        printAllShips();&#10;        printFloatingShips();&#10;        printShipsByCategory(&quot;Galeao&quot;);&#10;        printShipsByCategory(&quot;Fragata&quot;);&#10;        printShipsByCategory(&quot;Nau&quot;);&#10;        printShipsByCategory(&quot;Caravela&quot;);&#10;        printShipsByCategory(&quot;Barca&quot;);&#10;    }&#10;&#10;    /**&#10;     * Print ships of a particular category.&#10;     *&#10;     * @param category The category of ships of interest&#10;     */&#10;    public void printShipsByCategory(String category) {&#10;        assert category != null;&#10;&#10;        printShips(getShipsLike(category));&#10;    }&#10;&#10;    /**&#10;     * Print ships that are not yet shot.&#10;     */&#10;    public void printFloatingShips() {&#10;        printShips(getFloatingShips());&#10;    }&#10;&#10;    /**&#10;     * Print all registered ships.&#10;     */&#10;    void printAllShips() {&#10;        printShips(ships);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Frigate.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Frigate.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Frigate extends Ship {&#10;    private static final Integer SIZE = 4;&#10;    private static final String NAME = &quot;Fragata&quot;;&#10;&#10;    /**&#10;     * @param bearing&#10;     * @param pos&#10;     */&#10;    public Frigate(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Frigate.NAME, bearing, pos);&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for thr frigate&quot;);&#10;        }&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.Ship#getSize()&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Frigate.SIZE;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Frigate ship implementation (length 4).&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Frigate extends Ship {&#10;    private static final Integer SIZE = 4;&#10;    private static final String NAME = &quot;Fragata&quot;;&#10;&#10;    /**&#10;     * Build a Frigate oriented along the given bearing.&#10;     *&#10;     * @param bearing orientation for placement&#10;     * @param pos     starting reference position&#10;     * @throws IllegalArgumentException if bearing is invalid&#10;     */&#10;    public Frigate(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Frigate.NAME, bearing, pos);&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for thr frigate&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns the fixed size (number of cells) of this ship type.&#10;     *&#10;     * @return ship size in grid cells&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Frigate.SIZE;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Game.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Game.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * @author fba&#10; *&#10; */&#10;public class Game implements IGame {&#10;    private IFleet fleet;&#10;    private List&lt;IPosition&gt; shots;&#10;&#10;    private Integer countInvalidShots;&#10;    private Integer countRepeatedShots;&#10;    private Integer countHits;&#10;    private Integer countSinks;&#10;&#10;&#10;    /**&#10;     * @param fleet&#10;     */&#10;    public Game(IFleet fleet) {&#10;        shots = new ArrayList&lt;&gt;();&#10;        countInvalidShots = 0;&#10;        countRepeatedShots = 0;&#10;        this.fleet = fleet;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IGame#fire(battleship.IPosition)&#10;     */&#10;    @Override&#10;    public IShip fire(IPosition pos) {&#10;        if (!validShot(pos))&#10;            countInvalidShots++;&#10;        else { // valid shot!&#10;            if (repeatedShot(pos))&#10;                countRepeatedShots++;&#10;            else {&#10;                shots.add(pos);&#10;                IShip s = fleet.shipAt(pos);&#10;                if (s != null) {&#10;                    s.shoot(pos);&#10;                    countHits++;&#10;                    if (!s.stillFloating()) {&#10;                        countSinks++;&#10;                        return s;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IGame#getShots()&#10;     */&#10;    @Override&#10;    public List&lt;IPosition&gt; getShots() {&#10;        return shots;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IGame#getRepeatedShots()&#10;     */&#10;    @Override&#10;    public int getRepeatedShots() {&#10;        return this.countRepeatedShots;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IGame#getInvalidShots()&#10;     */&#10;    @Override&#10;    public int getInvalidShots() {&#10;        return this.countInvalidShots;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IGame#getHits()&#10;     */&#10;    @Override&#10;    public int getHits() {&#10;        return this.countHits;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IGame#getSunkShips()&#10;     */&#10;    @Override&#10;    public int getSunkShips() {&#10;        return this.countSinks;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IGame#getRemainingShips()&#10;     */&#10;    @Override&#10;    public int getRemainingShips() {&#10;        List&lt;IShip&gt; floatingShips = fleet.getFloatingShips();&#10;        return floatingShips.size();&#10;    }&#10;&#10;    private boolean validShot(IPosition pos) {&#10;        return (pos.getRow() &gt;= 0 &amp;&amp; pos.getRow() &lt;= Fleet.BOARD_SIZE &amp;&amp; pos.getColumn() &gt;= 0&#10;                &amp;&amp; pos.getColumn() &lt;= Fleet.BOARD_SIZE);&#10;    }&#10;&#10;    private boolean repeatedShot(IPosition pos) {&#10;        for (int i = 0; i &lt; shots.size(); i++)&#10;            if (shots.get(i).equals(pos))&#10;                return true;&#10;        return false;&#10;    }&#10;&#10;&#10;    public void printBoard(List&lt;IPosition&gt; positions, Character marker) {&#10;        char[][] map = new char[Fleet.BOARD_SIZE][Fleet.BOARD_SIZE];&#10;&#10;        for (int r = 0; r &lt; Fleet.BOARD_SIZE; r++)&#10;            for (int c = 0; c &lt; Fleet.BOARD_SIZE; c++)&#10;                map[r][c] = '.';&#10;&#10;        for (IPosition pos : positions)&#10;            map[pos.getRow()][pos.getColumn()] = marker;&#10;&#10;        for (int row = 0; row &lt; Fleet.BOARD_SIZE; row++) {&#10;            for (int col = 0; col &lt; Fleet.BOARD_SIZE; col++)&#10;                System.out.print(map[row][col]);&#10;            System.out.println();&#10;        }&#10;&#10;    }&#10;&#10;&#10;    /**&#10;     * Prints the board showing valid shots that have been fired&#10;     */&#10;    public void printValidShots() {&#10;        printBoard(getShots(), 'X');&#10;    }&#10;&#10;&#10;    /**&#10;     * Prints the board showing the fleet&#10;     */&#10;    public void printFleet() {&#10;        List&lt;IPosition&gt; shipPositions = new ArrayList&lt;IPosition&gt;();&#10;&#10;        for (IShip s : fleet.getShips())&#10;            shipPositions.addAll(s.getPositions());&#10;&#10;        printBoard(shipPositions, '#');&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game controller handling firing, tracking shots and reporting statistics.&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * @author fba&#10; *&#10; */&#10;public class Game implements IGame {&#10;    private IFleet fleet;&#10;    private List&lt;IPosition&gt; shots;&#10;&#10;    private Integer countInvalidShots;&#10;    private Integer countRepeatedShots;&#10;    private Integer countHits;&#10;    private Integer countSinks;&#10;&#10;&#10;    /**&#10;     * Create a Game attached to the provided fleet.&#10;     *&#10;     * @param fleet fleet instance that the game will manage and use for shots/placement&#10;     */&#10;    public Game(IFleet fleet) {&#10;        shots = new ArrayList&lt;&gt;();&#10;        countInvalidShots = 0;&#10;        countRepeatedShots = 0;&#10;        this.fleet = fleet;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IGame#fire(battleship.IPosition)&#10;     */&#10;    @Override&#10;    public IShip fire(IPosition pos) {&#10;        if (!validShot(pos))&#10;            countInvalidShots++;&#10;        else { // valid shot!&#10;            if (repeatedShot(pos))&#10;                countRepeatedShots++;&#10;            else {&#10;                shots.add(pos);&#10;                IShip s = fleet.shipAt(pos);&#10;                if (s != null) {&#10;                    s.shoot(pos);&#10;                    countHits++;&#10;                    if (!s.stillFloating()) {&#10;                        countSinks++;&#10;                        return s;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Returns the list of all recorded shots.&#10;     *&#10;     * @return list of positions fired upon&#10;     */&#10;    @Override&#10;    public List&lt;IPosition&gt; getShots() {&#10;        return shots;&#10;    }&#10;&#10;    /**&#10;     * Number of repeated shots (shots targeting an already fired position).&#10;     *&#10;     * @return repeated shot count&#10;     */&#10;    @Override&#10;    public int getRepeatedShots() {&#10;        return this.countRepeatedShots;&#10;    }&#10;&#10;    /**&#10;     * Number of invalid shots (e.g. out of bounds).&#10;     *&#10;     * @return invalid shot count&#10;     */&#10;    @Override&#10;    public int getInvalidShots() {&#10;        return this.countInvalidShots;&#10;    }&#10;&#10;    /**&#10;     * Number of successful hit events recorded.&#10;     *&#10;     * @return hits count&#10;     */&#10;    @Override&#10;    public int getHits() {&#10;        return this.countHits;&#10;    }&#10;&#10;    /**&#10;     * Number of ships sunk so far.&#10;     *&#10;     * @return sunk ships count&#10;     */&#10;    @Override&#10;    public int getSunkShips() {&#10;        return this.countSinks;&#10;    }&#10;&#10;    /**&#10;     * Number of ships still floating.&#10;     *&#10;     * @return remaining ships count&#10;     */&#10;    @Override&#10;    public int getRemainingShips() {&#10;        List&lt;IShip&gt; floatingShips = fleet.getFloatingShips();&#10;        return floatingShips.size();&#10;    }&#10;&#10;    private boolean validShot(IPosition pos) {&#10;        return (pos.getRow() &gt;= 0 &amp;&amp; pos.getRow() &lt;= Fleet.BOARD_SIZE &amp;&amp; pos.getColumn() &gt;= 0&#10;                &amp;&amp; pos.getColumn() &lt;= Fleet.BOARD_SIZE);&#10;    }&#10;&#10;    private boolean repeatedShot(IPosition pos) {&#10;        for (int i = 0; i &lt; shots.size(); i++)&#10;            if (shots.get(i).equals(pos))&#10;                return true;&#10;        return false;&#10;    }&#10;&#10;&#10;    /**&#10;     * Prints the given positions on a simple ASCII board using the provided marker.&#10;     *&#10;     * @param positions positions to mark on the printed board&#10;     * @param marker    character used to mark the provided positions when printing&#10;     */&#10;    public void printBoard(List&lt;IPosition&gt; positions, Character marker) {&#10;        char[][] map = new char[Fleet.BOARD_SIZE][Fleet.BOARD_SIZE];&#10;&#10;        for (int r = 0; r &lt; Fleet.BOARD_SIZE; r++)&#10;            for (int c = 0; c &lt; Fleet.BOARD_SIZE; c++)&#10;                map[r][c] = '.';&#10;&#10;        for (IPosition pos : positions)&#10;            map[pos.getRow()][pos.getColumn()] = marker;&#10;&#10;        for (int row = 0; row &lt; Fleet.BOARD_SIZE; row++) {&#10;            for (int col = 0; col &lt; Fleet.BOARD_SIZE; col++)&#10;                System.out.print(map[row][col]);&#10;            System.out.println();&#10;        }&#10;&#10;    }&#10;&#10;&#10;    /**&#10;     * Prints the board showing valid shots that have been fired.&#10;     */&#10;    public void printValidShots() {&#10;        printBoard(getShots(), 'X');&#10;    }&#10;&#10;&#10;    /**&#10;     * Prints the board showing the fleet.&#10;     */&#10;    public void printFleet() {&#10;        List&lt;IPosition&gt; shipPositions = new ArrayList&lt;IPosition&gt;();&#10;&#10;        for (IShip s : fleet.getShips())&#10;            shipPositions.addAll(s.getPositions());&#10;&#10;        printBoard(shipPositions, '#');&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/IGame.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/IGame.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.List;&#10;&#10;public interface IGame {&#10;    IShip fire(IPosition pos);&#10;&#10;    List&lt;IPosition&gt; getShots();&#10;&#10;    int getRepeatedShots();&#10;&#10;    int getInvalidShots();&#10;&#10;    int getHits();&#10;&#10;    int getSunkShips();&#10;&#10;    int getRemainingShips();&#10;&#10;    void printValidShots();&#10;&#10;    void printFleet();&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Game API for firing at positions and querying shot statistics.&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.List;&#10;&#10;public interface IGame {&#10;    /**&#10;     * Fire a shot at the given board position.&#10;     *&#10;     * @param pos the target position to fire at&#10;     * @return the ship hit at that position, or null if the shot missed or sank nothing&#10;     */&#10;    IShip fire(IPosition pos);&#10;&#10;    /**&#10;     * Returns the list of all positions that have been fired upon.&#10;     *&#10;     * @return list of fired positions (in chronological order)&#10;     */&#10;    List&lt;IPosition&gt; getShots();&#10;&#10;    /**&#10;     * Number of shots that repeated a previously fired position.&#10;     *&#10;     * @return repeated shot count&#10;     */&#10;    int getRepeatedShots();&#10;&#10;    /**&#10;     * Number of invalid shots (e.g., out of bounds).&#10;     *&#10;     * @return invalid shot count&#10;     */&#10;    int getInvalidShots();&#10;&#10;    /**&#10;     * Number of successful hits recorded.&#10;     *&#10;     * @return hit count&#10;     */&#10;    int getHits();&#10;&#10;    /**&#10;     * Number of ships that have been sunk.&#10;     *&#10;     * @return sunk ships count&#10;     */&#10;    int getSunkShips();&#10;&#10;    /**&#10;     * Number of ships still floating (not sunk).&#10;     *&#10;     * @return remaining ship count&#10;     */&#10;    int getRemainingShips();&#10;&#10;    /**&#10;     * Print a board view showing valid shots.&#10;     */&#10;    void printValidShots();&#10;&#10;    /**&#10;     * Print a board view showing the fleet positions.&#10;     */&#10;    void printFleet();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/IPosition.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/IPosition.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;/**&#10; * @author fba&#10; */&#10;public interface IPosition {&#10;    int getRow();&#10;&#10;    int getColumn();&#10;&#10;    boolean equals(Object other);&#10;&#10;    boolean isAdjacentTo(IPosition other);&#10;&#10;    void occupy();&#10;&#10;    void shoot();&#10;&#10;    boolean isOccupied();&#10;&#10;    boolean isHit();&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Represents a coordinate on the game board.&#10; * Provides information about occupancy and hit status and basic actions&#10; * (occupy, shoot) as well as adjacency checks.&#10; *&#10; * Implementations are expected to be immutable in coordinates but mutable&#10; * in occupancy/hit state.&#10; *&#10; * @author fba&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;/**&#10; * @author fba&#10; */&#10;public interface IPosition {&#10;&#10;    /**&#10;     * Returns the row index of this position.&#10;     *&#10;     * @return row index&#10;     */&#10;    int getRow();&#10;&#10;    /**&#10;     * Returns the column index of this position.&#10;     *&#10;     * @return column index&#10;     */&#10;    int getColumn();&#10;&#10;    /**&#10;     * Equality is based on row and column coordinates only.&#10;     *&#10;     * @param other object to compare&#10;     * @return true if coordinates are the same&#10;     */&#10;    boolean equals(Object other);&#10;&#10;    /**&#10;     * Checks whether this position is adjacent (including diagonals) to {@code other}.&#10;     *&#10;     * @param other position to compare&#10;     * @return true if positions are at most 1 cell apart in both dimensions&#10;     */&#10;    boolean isAdjacentTo(IPosition other);&#10;&#10;    /**&#10;     * Mark this position as occupied by a ship.&#10;     */&#10;    void occupy();&#10;&#10;    /**&#10;     * Mark this position as having been shot (hit).&#10;     */&#10;    void shoot();&#10;&#10;    /**&#10;     * Indicates whether this position is occupied by a ship.&#10;     *&#10;     * @return true if occupied&#10;     */&#10;    boolean isOccupied();&#10;&#10;    /**&#10;     * Indicates whether this position has been shot.&#10;     *&#10;     * @return true if hit&#10;     */&#10;    boolean isHit();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Tasks.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Tasks.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.Scanner;&#10;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;public class Tasks {&#10;    private static final Logger LOGGER = LogManager.getLogger();&#10;&#10;    private static final int NUMBER_SHOTS = 3;&#10;&#10;    private static final String GOODBYE_MESSAGE = &quot;Bons ventos!&quot;;&#10;&#10;    /**&#10;     * Strings to be used by the user&#10;     */&#10;    private static final String NOVAFROTA = &quot;nova&quot;;&#10;    private static final String DESISTIR = &quot;desisto&quot;;&#10;    private static final String RAJADA = &quot;rajada&quot;;&#10;    private static final String VERTIROS = &quot;ver&quot;;&#10;    private static final String BATOTA = &quot;mapa&quot;;&#10;    private static final String STATUS = &quot;estado&quot;;&#10;&#10;&#10;    /////////////////////////////////////////////////////////////////////////////&#10;    // hereafter one may find some code that can be converted to automatic tests,&#10;    // as long as appropriate changes are made. It also shows that we should&#10;    // develop our code incrementally e.g. first the ships, then the fleet,&#10;    // then some rule checking, then dealing with firing and so on&#10;    /////////////////////////////////////////////////////////////////////////////&#10;&#10;    /**&#10;     * This task tests the building up of ships: For each ship, reads positions and&#10;     * indicates whether the ship occupies each one of such positions or not&#10;     */&#10;    public static void taskA() {&#10;        Scanner in = new Scanner(System.in);&#10;        while (in.hasNext()) {&#10;            Ship s = readShip(in);&#10;            if (s != null)&#10;                for (int i = 0; i &lt; NUMBER_SHOTS; i++) {&#10;                    Position p = readPosition(in);&#10;                    LOGGER.info(&quot;{} {}&quot;, p, s.occupies(p));&#10;                }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * This task tests the building up of fleets&#10;     */&#10;    public static void taskB(Game game) {&#10;        Scanner in = new Scanner(System.in);&#10;        IFleet fleet = null;&#10;        String command = in.next();&#10;        while (!command.equals(DESISTIR)) {&#10;            switch (command) {&#10;                case NOVAFROTA:&#10;                    fleet = buildFleet(in);&#10;                    break;&#10;                case STATUS:&#10;                    if (fleet != null)&#10;                        fleet.printStatus();&#10;                    break;&#10;                default:&#10;                    LOGGER.info(&quot;Que comando é esse??? Repete lá ...&quot;);&#10;            }&#10;            // The other commands are unknown in this task&#10;            command = in.next();&#10;        }&#10;        LOGGER.info(GOODBYE_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * This task tests the building up of fleets and takes into consideration the&#10;     * possibility of cheating&#10;     */&#10;    public static void taskC() {&#10;        Scanner in = new Scanner(System.in);&#10;        IFleet fleet = null;&#10;        String command = in.next();&#10;        while (!command.equals(DESISTIR)) {&#10;            switch (command) {&#10;                case NOVAFROTA:&#10;                    fleet = buildFleet(in);&#10;                    break;&#10;                case STATUS:&#10;                    if (fleet != null)&#10;                        fleet.printStatus();&#10;                    break;&#10;                case BATOTA:&#10;                    LOGGER.info(fleet);&#10;                    break;&#10;                default:&#10;                    LOGGER.info(&quot;Que comando é esse??? Repete lá ...&quot;);&#10;            }&#10;            // The other commands are unknown in this task&#10;            command = in.next();&#10;        }&#10;        LOGGER.info(GOODBYE_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * This task also tests the fighting element of a round of three shots&#10;     */&#10;    public static void taskD() {&#10;&#10;        Scanner in = new Scanner(System.in);&#10;        IFleet fleet = null;&#10;        IGame game = null;&#10;        String command = in.next();&#10;        while (!command.equals(DESISTIR)) {&#10;            switch (command) {&#10;                case NOVAFROTA:&#10;                    fleet = buildFleet(in);&#10;                    game = new Game(fleet);&#10;                    break;&#10;                case STATUS:&#10;                    if (fleet != null)&#10;                        fleet.printStatus();&#10;                    break;&#10;                case BATOTA:&#10;                    if (fleet != null)&#10;                        game.printFleet();&#10;                    break;&#10;                case RAJADA:&#10;                    if (game != null) {&#10;                        firingRound(in, game);&#10;&#10;                        LOGGER.info(&quot;Hits: {} Inv: {} Rep: {} Restam {} navios.&quot;, game.getHits(), game.getInvalidShots(),&#10;                                game.getRepeatedShots(), game.getRemainingShips());&#10;                        if (game.getRemainingShips() == 0)&#10;                            LOGGER.info(&quot;Maldito sejas, Java Sparrow, eu voltarei, glub glub glub...&quot;);&#10;                    }&#10;                    break;&#10;                case VERTIROS:&#10;                    if (game != null)&#10;                        game.printValidShots();&#10;                    break;&#10;                default:&#10;                    LOGGER.info(&quot;Que comando é esse??? Repete ...&quot;);&#10;            }&#10;            command = in.next();&#10;        }&#10;        LOGGER.info(GOODBYE_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * This operation allows the build up of a fleet, given user data&#10;     *&#10;     * @param in The scanner to read from&#10;     * @return The fleet that has been built&#10;     */&#10;    static Fleet buildFleet(Scanner in) {&#10;        assert in != null;&#10;&#10;        Fleet fleet = new Fleet();&#10;        int i = 0; // i represents the total of successfully created ships&#10;&#10;        while (i &lt;= Fleet.FLEET_SIZE) {&#10;            IShip s = readShip(in);&#10;            if (s != null) {&#10;                boolean success = fleet.addShip(s);&#10;                if (success)&#10;                    i++;&#10;                else&#10;                    LOGGER.info(&quot;Falha na criacao de {} {} {}&quot;, s.getCategory(), s.getBearing(), s.getPosition());&#10;            } else {&#10;                LOGGER.info(&quot;Navio desconhecido!&quot;);&#10;            }&#10;        }&#10;        LOGGER.info(&quot;{} navios adicionados com sucesso!&quot;, i);&#10;        return fleet;&#10;    }&#10;&#10;    /**&#10;     * This operation reads data about a ship, build it and returns it&#10;     *&#10;     * @param in The scanner to read from&#10;     * @return The created ship based on the data that has been read&#10;     */&#10;    static Ship readShip(Scanner in) {&#10;        String shipKind = in.next();&#10;        Position pos = readPosition(in);&#10;        char c = in.next().charAt(0);&#10;        Compass bearing = Compass.charToCompass(c);&#10;        return Ship.buildShip(shipKind, bearing, pos);&#10;    }&#10;&#10;    /**&#10;     * This operation allows reading a position in the map&#10;     *&#10;     * @param in The scanner to read from&#10;     * @return The position that has been read&#10;     */&#10;    static Position readPosition(Scanner in) {&#10;        int row = in.nextInt();&#10;        int column = in.nextInt();&#10;        return new Position(row, column);&#10;    }&#10;&#10;    /**&#10;     * This operation allows firing a round of shots (three) over a fleet, in the&#10;     * context of a game&#10;     *&#10;     * @param in   The scanner to read from&#10;     * @param game The context game while fleet is being attacked&#10;     */&#10;    static void firingRound(Scanner in, IGame game) {&#10;        for (int i = 0; i &lt; NUMBER_SHOTS; i++) {&#10;            IPosition pos = readPosition(in);&#10;            IShip sh = game.fire(pos);&#10;            if (sh != null)&#10;                LOGGER.info(&quot;Mas... mas... {}s nao sao a prova de bala? :-(&quot;, sh.getCategory());&#10;        }&#10;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.Scanner;&#10;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;/**&#10; * Small set of console tasks used for manual testing / exercises.&#10; * Methods read input from a Scanner and exercise ship/fleet/game behaviour.&#10; */&#10;public class Tasks {&#10;    private static final Logger LOGGER = LogManager.getLogger();&#10;&#10;    private static final int NUMBER_SHOTS = 3;&#10;&#10;    private static final String GOODBYE_MESSAGE = &quot;Bons ventos!&quot;;&#10;&#10;    /**&#10;     * Strings to be used by the user&#10;     */&#10;    private static final String NOVAFROTA = &quot;nova&quot;;&#10;    private static final String DESISTIR = &quot;desisto&quot;;&#10;    private static final String RAJADA = &quot;rajada&quot;;&#10;    private static final String VERTIROS = &quot;ver&quot;;&#10;    private static final String BATOTA = &quot;mapa&quot;;&#10;    private static final String STATUS = &quot;estado&quot;;&#10;&#10;&#10;    /////////////////////////////////////////////////////////////////////////////&#10;    // hereafter one may find some code that can be converted to automatic tests,&#10;    // as long as appropriate changes are made. It also shows that we should&#10;    // develop our code incrementally e.g. first the ships, then the fleet,&#10;    // then some rule checking, then dealing with firing and so on&#10;    /////////////////////////////////////////////////////////////////////////////&#10;&#10;    /**&#10;     * This task tests the building up of ships: For each ship, reads positions and&#10;     * indicates whether the ship occupies each one of such positions or not&#10;     */&#10;    public static void taskA() {&#10;        Scanner in = new Scanner(System.in);&#10;        while (in.hasNext()) {&#10;            Ship s = readShip(in);&#10;            if (s != null)&#10;                for (int i = 0; i &lt; NUMBER_SHOTS; i++) {&#10;                    Position p = readPosition(in);&#10;                    LOGGER.info(&quot;{} {}&quot;, p, s.occupies(p));&#10;                }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * This task tests the building up of fleets&#10;     *&#10;     * @param game unused parameter in the task (kept for compatibility)&#10;     */&#10;    public static void taskB(Game game) {&#10;        Scanner in = new Scanner(System.in);&#10;        IFleet fleet = null;&#10;        String command = in.next();&#10;        while (!command.equals(DESISTIR)) {&#10;            switch (command) {&#10;                case NOVAFROTA:&#10;                    fleet = buildFleet(in);&#10;                    break;&#10;                case STATUS:&#10;                    if (fleet != null)&#10;                        fleet.printStatus();&#10;                    break;&#10;                default:&#10;                    LOGGER.info(&quot;Que comando é esse??? Repete lá ...&quot;);&#10;            }&#10;            // The other commands are unknown in this task&#10;            command = in.next();&#10;        }&#10;        LOGGER.info(GOODBYE_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * This task tests the building up of fleets and takes into consideration the&#10;     * possibility of cheating&#10;     */&#10;    public static void taskC() {&#10;        Scanner in = new Scanner(System.in);&#10;        IFleet fleet = null;&#10;        String command = in.next();&#10;        while (!command.equals(DESISTIR)) {&#10;            switch (command) {&#10;                case NOVAFROTA:&#10;                    fleet = buildFleet(in);&#10;                    break;&#10;                case STATUS:&#10;                    if (fleet != null)&#10;                        fleet.printStatus();&#10;                    break;&#10;                case BATOTA:&#10;                    LOGGER.info(fleet);&#10;                    break;&#10;                default:&#10;                    LOGGER.info(&quot;Que comando é esse??? Repete lá ...&quot;);&#10;            }&#10;            // The other commands are unknown in this task&#10;            command = in.next();&#10;        }&#10;        LOGGER.info(GOODBYE_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * This task also tests the fighting element of a round of three shots&#10;     */&#10;    public static void taskD() {&#10;&#10;        Scanner in = new Scanner(System.in);&#10;        IFleet fleet = null;&#10;        IGame game = null;&#10;        String command = in.next();&#10;        while (!command.equals(DESISTIR)) {&#10;            switch (command) {&#10;                case NOVAFROTA:&#10;                    fleet = buildFleet(in);&#10;                    game = new Game(fleet);&#10;                    break;&#10;                case STATUS:&#10;                    if (fleet != null)&#10;                        fleet.printStatus();&#10;                    break;&#10;                case BATOTA:&#10;                    if (fleet != null)&#10;                        game.printFleet();&#10;                    break;&#10;                case RAJADA:&#10;                    if (game != null) {&#10;                        firingRound(in, game);&#10;&#10;                        LOGGER.info(&quot;Hits: {} Inv: {} Rep: {} Restam {} navios.&quot;, game.getHits(), game.getInvalidShots(),&#10;                                game.getRepeatedShots(), game.getRemainingShips());&#10;                        if (game.getRemainingShips() == 0)&#10;                            LOGGER.info(&quot;Maldito sejas, Java Sparrow, eu voltarei, glub glub glub...&quot;);&#10;                    }&#10;                    break;&#10;                case VERTIROS:&#10;                    if (game != null)&#10;                        game.printValidShots();&#10;                    break;&#10;                default:&#10;                    LOGGER.info(&quot;Que comando é esse??? Repete ...&quot;);&#10;            }&#10;            command = in.next();&#10;        }&#10;        LOGGER.info(GOODBYE_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * Build a fleet reading ships from the provided scanner.&#10;     *&#10;     * @param in the scanner to read ship data from&#10;     * @return constructed Fleet&#10;     */&#10;    static Fleet buildFleet(Scanner in) {&#10;        assert in != null;&#10;&#10;        Fleet fleet = new Fleet();&#10;        int i = 0; // i represents the total of successfully created ships&#10;&#10;        while (i &lt;= Fleet.FLEET_SIZE) {&#10;            IShip s = readShip(in);&#10;            if (s != null) {&#10;                boolean success = fleet.addShip(s);&#10;                if (success)&#10;                    i++;&#10;                else&#10;                    LOGGER.info(&quot;Falha na criacao de {} {} {}&quot;, s.getCategory(), s.getBearing(), s.getPosition());&#10;            } else {&#10;                LOGGER.info(&quot;Navio desconhecido!&quot;);&#10;            }&#10;        }&#10;        LOGGER.info(&quot;{} navios adicionados com sucesso!&quot;, i);&#10;        return fleet;&#10;    }&#10;&#10;    /**&#10;     * Read a ship specification from the scanner and create it.&#10;     *&#10;     * @param in input scanner&#10;     * @return created Ship or null when unknown&#10;     */&#10;    static Ship readShip(Scanner in) {&#10;        String shipKind = in.next();&#10;        Position pos = readPosition(in);&#10;        char c = in.next().charAt(0);&#10;        Compass bearing = Compass.charToCompass(c);&#10;        return Ship.buildShip(shipKind, bearing, pos);&#10;    }&#10;&#10;    /**&#10;     * Read a position (two integers) from the scanner.&#10;     *&#10;     * @param in scanner to read from&#10;     * @return created Position&#10;     */&#10;    static Position readPosition(Scanner in) {&#10;        int row = in.nextInt();&#10;        int column = in.nextInt();&#10;        return new Position(row, column);&#10;    }&#10;&#10;    /**&#10;     * Fire a fixed number of shots (round) using the provided game.&#10;     *&#10;     * @param in   scanner for input coordinates&#10;     * @param game game instance used to fire shots&#10;     */&#10;    static void firingRound(Scanner in, IGame game) {&#10;        for (int i = 0; i &lt; NUMBER_SHOTS; i++) {&#10;            IPosition pos = readPosition(in);&#10;            IShip sh = game.fire(pos);&#10;            if (sh != null)&#10;                LOGGER.info(&quot;Mas... mas... {}s nao sao a prova de bala? :-(&quot;, sh.getCategory());&#10;        }&#10;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>