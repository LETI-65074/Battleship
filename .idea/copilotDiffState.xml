<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Barge.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Barge.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Barge extends Ship {&#10;    private static final Integer SIZE = 1;&#10;    private static final String NAME = &quot;Barca&quot;;&#10;&#10;    /**&#10;     * @param bearing - barge bearing&#10;     * @param pos     - upper left position of the barge&#10;     */&#10;    public Barge(Compass bearing, IPosition pos) {&#10;        super(Barge.NAME, bearing, pos);&#10;        getPositions().add(new Position(pos.getRow(), pos.getColumn()));&#10;    }&#10;&#10;    @Override&#10;    public Integer getSize() {&#10;        return SIZE;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Single-cell ship (Barge).&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Barge extends Ship {&#10;    private static final Integer SIZE = 1;&#10;    private static final String NAME = &quot;Barca&quot;;&#10;&#10;    /**&#10;     * Create a single-cell Barge at the provided position.&#10;     *&#10;     * @param bearing the bearing of the barge (ignored for size 1 but kept for API consistency)&#10;     * @param pos     upper-left position of the barge (its single occupied cell)&#10;     */&#10;    public Barge(Compass bearing, IPosition pos) {&#10;        super(Barge.NAME, bearing, pos);&#10;        getPositions().add(new Position(pos.getRow(), pos.getColumn()));&#10;    }&#10;&#10;    /**&#10;     * Returns the fixed size (number of cells) of this ship type.&#10;     *&#10;     * @return ship size in grid cells&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return SIZE;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Caravel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Caravel.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Caravel extends Ship {&#10;    private static final Integer SIZE = 2;&#10;    private static final String NAME = &quot;Caravela&quot;;&#10;&#10;    /**&#10;     * @param bearing the bearing where the Caravel heads to&#10;     * @param pos     initial point for positioning the Caravel&#10;     */&#10;    public Caravel(Compass bearing, IPosition pos) throws NullPointerException, IllegalArgumentException {&#10;        super(Caravel.NAME, bearing, pos);&#10;&#10;        if (bearing == null)&#10;            throw new NullPointerException(&quot;ERROR! invalid bearing for the caravel&quot;);&#10;&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for the caravel&quot;);&#10;        }&#10;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.Ship#getSize()&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return SIZE;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Small two-cell ship implementation (Caravel).&#10; * The Caravel occupies SIZE consecutive cells in the given bearing&#10; * starting at the provided position.&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Caravel extends Ship {&#10;    private static final Integer SIZE = 2;&#10;    private static final String NAME = &quot;Caravela&quot;;&#10;&#10;    /**&#10;     * Create a Caravel oriented along the given bearing with its&#10;     * reference position at pos.&#10;     *&#10;     * @param bearing the bearing where the Caravel heads to (orientation)&#10;     * @param pos     initial point for positioning the Caravel (reference cell)&#10;     * @throws NullPointerException     if bearing is null&#10;     * @throws IllegalArgumentException if the bearing value is unsupported&#10;     */&#10;    public Caravel(Compass bearing, IPosition pos) throws NullPointerException, IllegalArgumentException {&#10;        super(Caravel.NAME, bearing, pos);&#10;&#10;        if (bearing == null)&#10;            throw new NullPointerException(&quot;ERROR! invalid bearing for the caravel&quot;);&#10;&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for the caravel&quot;);&#10;        }&#10;&#10;    }&#10;&#10;    /**&#10;     * Returns the fixed size (number of cells) of this ship type.&#10;     *&#10;     * @return ship size in grid cells&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return SIZE;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Carrack.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Carrack.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Carrack extends Ship {&#10;    private static final Integer SIZE = 3;&#10;    private static final String NAME = &quot;Nau&quot;;&#10;&#10;    /**&#10;     * @param bearing&#10;     * @param pos&#10;     */&#10;    public Carrack(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Carrack.NAME, bearing, pos);&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for the carrack&quot;);&#10;        }&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.Ship#getSize()&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Carrack.SIZE;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Carrack ship implementation (length 3).&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Carrack extends Ship {&#10;    private static final Integer SIZE = 3;&#10;    private static final String NAME = &quot;Nau&quot;;&#10;&#10;    /**&#10;     * Construct a Carrack oriented along the given bearing.&#10;     *&#10;     * @param bearing orientation for placement&#10;     * @param pos     reference starting position&#10;     * @throws IllegalArgumentException if bearing is invalid&#10;     */&#10;    public Carrack(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Carrack.NAME, bearing, pos);&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for the carrack&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns the fixed size (number of cells) of this ship type.&#10;     *&#10;     * @return ship size in grid cells&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Carrack.SIZE;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Fleet.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Fleet.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Fleet implements IFleet {&#10;    /**&#10;     * This operation prints all the given ships&#10;     *&#10;     * @param ships The list of ships&#10;     */&#10;    static void printShips(List&lt;IShip&gt; ships) {&#10;        for (IShip ship : ships)&#10;            System.out.println(ship);&#10;    }&#10;&#10;    // -----------------------------------------------------&#10;&#10;    private List&lt;IShip&gt; ships;&#10;&#10;    public Fleet() {&#10;        ships = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public List&lt;IShip&gt; getShips() {&#10;        return ships;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#addShip(battleship.IShip)&#10;     */&#10;    @Override&#10;    public boolean addShip(IShip s) {&#10;        boolean result = false;&#10;        if ((ships.size() &lt;= FLEET_SIZE) &amp;&amp; (isInsideBoard(s)) &amp;&amp; (!colisionRisk(s))) {&#10;            ships.add(s);&#10;            result = true;&#10;        }&#10;        return result;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#getShipsLike(java.lang.String)&#10;     */&#10;    @Override&#10;    public List&lt;IShip&gt; getShipsLike(String category) {&#10;        List&lt;IShip&gt; shipsLike = new ArrayList&lt;&gt;();&#10;        for (IShip s : ships)&#10;            if (s.getCategory().equals(category))&#10;                shipsLike.add(s);&#10;&#10;        return shipsLike;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#getFloatingShips()&#10;     */&#10;    @Override&#10;    public List&lt;IShip&gt; getFloatingShips() {&#10;        List&lt;IShip&gt; floatingShips = new ArrayList&lt;&gt;();&#10;        for (IShip s : ships)&#10;            if (s.stillFloating())&#10;                floatingShips.add(s);&#10;&#10;        return floatingShips;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#shipAt(battleship.IPosition)&#10;     */&#10;    @Override&#10;    public IShip shipAt(IPosition pos) {&#10;        for (int i = 0; i &lt; ships.size(); i++)&#10;            if (ships.get(i).occupies(pos))&#10;                return ships.get(i);&#10;        return null;&#10;    }&#10;&#10;    private boolean isInsideBoard(IShip s) {&#10;        return (s.getLeftMostPos() &gt;= 0 &amp;&amp; s.getRightMostPos() &lt;= BOARD_SIZE - 1 &amp;&amp; s.getTopMostPos() &gt;= 0&#10;                &amp;&amp; s.getBottomMostPos() &lt;= BOARD_SIZE - 1);&#10;    }&#10;&#10;    private boolean colisionRisk(IShip s) {&#10;        for (int i = 0; i &lt; ships.size(); i++) {&#10;            if (ships.get(i).tooCloseTo(s))&#10;                return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;&#10;    /**&#10;     * This operation shows the state of a fleet&#10;     */&#10;    public void printStatus() {&#10;        printAllShips();&#10;        printFloatingShips();&#10;        printShipsByCategory(&quot;Galeao&quot;);&#10;        printShipsByCategory(&quot;Fragata&quot;);&#10;        printShipsByCategory(&quot;Nau&quot;);&#10;        printShipsByCategory(&quot;Caravela&quot;);&#10;        printShipsByCategory(&quot;Barca&quot;);&#10;    }&#10;&#10;    /**&#10;     * This operation prints all the ships of a fleet belonging to a particular&#10;     * category&#10;     *&#10;     * @param category The category of ships of interest&#10;     */&#10;    public void printShipsByCategory(String category) {&#10;        assert category != null;&#10;&#10;        printShips(getShipsLike(category));&#10;    }&#10;&#10;    /**&#10;     * This operation prints all the ships of a fleet but not yet shot&#10;     */&#10;    public void printFloatingShips() {&#10;        printShips(getFloatingShips());&#10;    }&#10;&#10;    /**&#10;     * This operation prints all the ships of a fleet&#10;     */&#10;    void printAllShips() {&#10;        printShips(ships);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Default implementation of IFleet. Manages ship storage and placement rules.&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Fleet implements IFleet {&#10;    /**&#10;     * Print a list of ships to stdout.&#10;     *&#10;     * @param ships The list of ships&#10;     */&#10;    static void printShips(List&lt;IShip&gt; ships) {&#10;        for (IShip ship : ships)&#10;            System.out.println(ship);&#10;    }&#10;&#10;    // -----------------------------------------------------&#10;&#10;    private List&lt;IShip&gt; ships;&#10;&#10;    public Fleet() {&#10;        ships = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public List&lt;IShip&gt; getShips() {&#10;        return ships;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#addShip(battleship.IShip)&#10;     */&#10;    @Override&#10;    public boolean addShip(IShip s) {&#10;        boolean result = false;&#10;        if ((ships.size() &lt;= FLEET_SIZE) &amp;&amp; (isInsideBoard(s)) &amp;&amp; (!colisionRisk(s))) {&#10;            ships.add(s);&#10;            result = true;&#10;        }&#10;        return result;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#getShipsLike(java.lang.String)&#10;     */&#10;    @Override&#10;    public List&lt;IShip&gt; getShipsLike(String category) {&#10;        List&lt;IShip&gt; shipsLike = new ArrayList&lt;&gt;();&#10;        for (IShip s : ships)&#10;            if (s.getCategory().equals(category))&#10;                shipsLike.add(s);&#10;&#10;        return shipsLike;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#getFloatingShips()&#10;     */&#10;    @Override&#10;    public List&lt;IShip&gt; getFloatingShips() {&#10;        List&lt;IShip&gt; floatingShips = new ArrayList&lt;&gt;();&#10;        for (IShip s : ships)&#10;            if (s.stillFloating())&#10;                floatingShips.add(s);&#10;&#10;        return floatingShips;&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.IFleet#shipAt(battleship.IPosition)&#10;     */&#10;    @Override&#10;    public IShip shipAt(IPosition pos) {&#10;        for (int i = 0; i &lt; ships.size(); i++)&#10;            if (ships.get(i).occupies(pos))&#10;                return ships.get(i);&#10;        return null;&#10;    }&#10;&#10;    private boolean isInsideBoard(IShip s) {&#10;        return (s.getLeftMostPos() &gt;= 0 &amp;&amp; s.getRightMostPos() &lt;= BOARD_SIZE - 1 &amp;&amp; s.getTopMostPos() &gt;= 0&#10;                &amp;&amp; s.getBottomMostPos() &lt;= BOARD_SIZE - 1);&#10;    }&#10;&#10;    private boolean colisionRisk(IShip s) {&#10;        for (int i = 0; i &lt; ships.size(); i++) {&#10;            if (ships.get(i).tooCloseTo(s))&#10;                return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;&#10;    /**&#10;     * Show the fleet status summary (prints categories and floating/sunk info).&#10;     */&#10;    public void printStatus() {&#10;        printAllShips();&#10;        printFloatingShips();&#10;        printShipsByCategory(&quot;Galeao&quot;);&#10;        printShipsByCategory(&quot;Fragata&quot;);&#10;        printShipsByCategory(&quot;Nau&quot;);&#10;        printShipsByCategory(&quot;Caravela&quot;);&#10;        printShipsByCategory(&quot;Barca&quot;);&#10;    }&#10;&#10;    /**&#10;     * Print ships of a particular category.&#10;     *&#10;     * @param category The category of ships of interest&#10;     */&#10;    public void printShipsByCategory(String category) {&#10;        assert category != null;&#10;&#10;        printShips(getShipsLike(category));&#10;    }&#10;&#10;    /**&#10;     * Print ships that are not yet shot.&#10;     */&#10;    public void printFloatingShips() {&#10;        printShips(getFloatingShips());&#10;    }&#10;&#10;    /**&#10;     * Print all registered ships.&#10;     */&#10;    void printAllShips() {&#10;        printShips(ships);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Frigate.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Frigate.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Frigate extends Ship {&#10;    private static final Integer SIZE = 4;&#10;    private static final String NAME = &quot;Fragata&quot;;&#10;&#10;    /**&#10;     * @param bearing&#10;     * @param pos&#10;     */&#10;    public Frigate(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Frigate.NAME, bearing, pos);&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for thr frigate&quot;);&#10;        }&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.Ship#getSize()&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Frigate.SIZE;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Frigate ship implementation (length 4).&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Frigate extends Ship {&#10;    private static final Integer SIZE = 4;&#10;    private static final String NAME = &quot;Fragata&quot;;&#10;&#10;    /**&#10;     * Build a Frigate oriented along the given bearing.&#10;     *&#10;     * @param bearing orientation for placement&#10;     * @param pos     starting reference position&#10;     * @throws IllegalArgumentException if bearing is invalid&#10;     */&#10;    public Frigate(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Frigate.NAME, bearing, pos);&#10;        switch (bearing) {&#10;            case NORTH:&#10;            case SOUTH:&#10;                for (int r = 0; r &lt; SIZE; r++)&#10;                    getPositions().add(new Position(pos.getRow() + r, pos.getColumn()));&#10;                break;&#10;            case EAST:&#10;            case WEST:&#10;                for (int c = 0; c &lt; SIZE; c++)&#10;                    getPositions().add(new Position(pos.getRow(), pos.getColumn() + c));&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for thr frigate&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns the fixed size (number of cells) of this ship type.&#10;     *&#10;     * @return ship size in grid cells&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Frigate.SIZE;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Galleon.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/Galleon.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Galleon extends Ship {&#10;    private static final Integer SIZE = 5;&#10;    private static final String NAME = &quot;Galeao&quot;;&#10;&#10;    /**&#10;     * @param bearing&#10;     * @param pos&#10;     */&#10;    public Galleon(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Galleon.NAME, bearing, pos);&#10;&#10;        if (bearing == null)&#10;            throw new NullPointerException(&quot;ERROR! invalid bearing for the galleon&quot;);&#10;&#10;        switch (bearing) {&#10;            case NORTH:&#10;                fillNorth(pos);&#10;                break;&#10;            case EAST:&#10;                fillEast(pos);&#10;                break;&#10;            case SOUTH:&#10;                fillSouth(pos);&#10;                break;&#10;            case WEST:&#10;                fillWest(pos);&#10;                break;&#10;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for the galleon&quot;);&#10;        }&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     *&#10;     * @see battleship.Ship#getSize()&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Galleon.SIZE;&#10;    }&#10;&#10;    private void fillNorth(IPosition pos) {&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            getPositions().add(new Position(pos.getRow(), pos.getColumn() + i));&#10;        }&#10;        getPositions().add(new Position(pos.getRow() + 1, pos.getColumn() + 1));&#10;        getPositions().add(new Position(pos.getRow() + 2, pos.getColumn() + 1));&#10;    }&#10;&#10;    private void fillSouth(IPosition pos) {&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            getPositions().add(new Position(pos.getRow() + i, pos.getColumn()));&#10;        }&#10;        for (int j = 2; j &lt; 5; j++) {&#10;            getPositions().add(new Position(pos.getRow() + 2, pos.getColumn() + j - 3));&#10;        }&#10;    }&#10;&#10;    private void fillEast(IPosition pos) {&#10;        getPositions().add(new Position(pos.getRow(), pos.getColumn()));&#10;        for (int i = 1; i &lt; 4; i++) {&#10;            getPositions().add(new Position(pos.getRow() + 1, pos.getColumn() + i - 3));&#10;        }&#10;        getPositions().add(new Position(pos.getRow() + 2, pos.getColumn()));&#10;    }&#10;&#10;    private void fillWest(IPosition pos) {&#10;        getPositions().add(new Position(pos.getRow(), pos.getColumn()));&#10;        for (int i = 1; i &lt; 4; i++) {&#10;            getPositions().add(new Position(pos.getRow() + 1, pos.getColumn() + i - 1));&#10;        }&#10;        getPositions().add(new Position(pos.getRow() + 2, pos.getColumn()));&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Galleon ship implementation (large, asymmetric shape).&#10; * The constructor fills the internal positions according to the selected bearing.&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;public class Galleon extends Ship {&#10;    private static final Integer SIZE = 5;&#10;    private static final String NAME = &quot;Galeao&quot;;&#10;&#10;    /**&#10;     * Construct a Galleon with the given orientation and reference position.&#10;     *&#10;     * @param bearing orientation of the Galleon&#10;     * @param pos     reference position used to compute occupied cells&#10;     * @throws NullPointerException     if bearing is null&#10;     * @throws IllegalArgumentException if the bearing is not supported for placement&#10;     */&#10;    public Galleon(Compass bearing, IPosition pos) throws IllegalArgumentException {&#10;        super(Galleon.NAME, bearing, pos);&#10;&#10;        if (bearing == null)&#10;            throw new NullPointerException(&quot;ERROR! invalid bearing for the galleon&quot;);&#10;&#10;        switch (bearing) {&#10;            case NORTH:&#10;                fillNorth(pos);&#10;                break;&#10;            case EAST:&#10;                fillEast(pos);&#10;                break;&#10;            case SOUTH:&#10;                fillSouth(pos);&#10;                break;&#10;            case WEST:&#10;                fillWest(pos);&#10;                break;&#10;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;ERROR! invalid bearing for the galleon&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns the fixed size (number of cells) of this ship type.&#10;     *&#10;     * @return ship size in grid cells&#10;     */&#10;    @Override&#10;    public Integer getSize() {&#10;        return Galleon.SIZE;&#10;    }&#10;&#10;    private void fillNorth(IPosition pos) {&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            getPositions().add(new Position(pos.getRow(), pos.getColumn() + i));&#10;        }&#10;        getPositions().add(new Position(pos.getRow() + 1, pos.getColumn() + 1));&#10;        getPositions().add(new Position(pos.getRow() + 2, pos.getColumn() + 1));&#10;    }&#10;&#10;    private void fillSouth(IPosition pos) {&#10;        for (int i = 0; i &lt; 2; i++) {&#10;            getPositions().add(new Position(pos.getRow() + i, pos.getColumn()));&#10;        }&#10;        for (int j = 2; j &lt; 5; j++) {&#10;            getPositions().add(new Position(pos.getRow() + 2, pos.getColumn() + j - 3));&#10;        }&#10;    }&#10;&#10;    private void fillEast(IPosition pos) {&#10;        getPositions().add(new Position(pos.getRow(), pos.getColumn()));&#10;        for (int i = 1; i &lt; 4; i++) {&#10;            getPositions().add(new Position(pos.getRow() + 1, pos.getColumn() + i - 3));&#10;        }&#10;        getPositions().add(new Position(pos.getRow() + 2, pos.getColumn()));&#10;    }&#10;&#10;    private void fillWest(IPosition pos) {&#10;        getPositions().add(new Position(pos.getRow(), pos.getColumn()));&#10;        for (int i = 1; i &lt; 4; i++) {&#10;            getPositions().add(new Position(pos.getRow() + 1, pos.getColumn() + i - 1));&#10;        }&#10;        getPositions().add(new Position(pos.getRow() + 2, pos.getColumn()));&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/IPosition.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/iscteiul/ista/battleship/IPosition.java" />
              <option name="originalContent" value="/**&#10; *&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;/**&#10; * @author fba&#10; */&#10;public interface IPosition {&#10;    int getRow();&#10;&#10;    int getColumn();&#10;&#10;    boolean equals(Object other);&#10;&#10;    boolean isAdjacentTo(IPosition other);&#10;&#10;    void occupy();&#10;&#10;    void shoot();&#10;&#10;    boolean isOccupied();&#10;&#10;    boolean isHit();&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Represents a coordinate on the game board.&#10; * Provides information about occupancy and hit status and basic actions&#10; * (occupy, shoot) as well as adjacency checks.&#10; *&#10; * Implementations are expected to be immutable in coordinates but mutable&#10; * in occupancy/hit state.&#10; *&#10; * @author fba&#10; */&#10;package iscteiul.ista.battleship;&#10;&#10;/**&#10; * @author fba&#10; */&#10;public interface IPosition {&#10;&#10;    /**&#10;     * Returns the row index of this position.&#10;     *&#10;     * @return row index&#10;     */&#10;    int getRow();&#10;&#10;    /**&#10;     * Returns the column index of this position.&#10;     *&#10;     * @return column index&#10;     */&#10;    int getColumn();&#10;&#10;    /**&#10;     * Equality is based on row and column coordinates only.&#10;     *&#10;     * @param other object to compare&#10;     * @return true if coordinates are the same&#10;     */&#10;    boolean equals(Object other);&#10;&#10;    /**&#10;     * Checks whether this position is adjacent (including diagonals) to {@code other}.&#10;     *&#10;     * @param other position to compare&#10;     * @return true if positions are at most 1 cell apart in both dimensions&#10;     */&#10;    boolean isAdjacentTo(IPosition other);&#10;&#10;    /**&#10;     * Mark this position as occupied by a ship.&#10;     */&#10;    void occupy();&#10;&#10;    /**&#10;     * Mark this position as having been shot (hit).&#10;     */&#10;    void shoot();&#10;&#10;    /**&#10;     * Indicates whether this position is occupied by a ship.&#10;     *&#10;     * @return true if occupied&#10;     */&#10;    boolean isOccupied();&#10;&#10;    /**&#10;     * Indicates whether this position has been shot.&#10;     *&#10;     * @return true if hit&#10;     */&#10;    boolean isHit();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>